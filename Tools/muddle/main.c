/* 
   main.c: Main for Muddle and Puddle.

   Chip Morningstar, Lucasfilm Ltd., 4-March-1986
    revised for Puddle 22-February-1987 -- CM
    revised to include width info 3-March-1987 -- CM
 */

#include "muddleTypes.h"
#include "muddleGlobals.h"

main(argc, argv)
  int	 argc;
  char	*argv[];
{
	void	initializeStuff();
	void	processClasses();
	void	outputResults();

	initializeStuff(argc, argv);
	yyparse();
	processClasses(inputClasses);
	outputResults();
}

  void
initializeStuff(argc, argv)
  int	 argc;
  char	*argv[];
{
	int	 i;
	FILE	*openFile();
	long	 theTime, time();

	inputClasses = NULL;
	classFile = openFile("class.dat", "wb", "class output file");
        classEquatesFile = openFile("class_equates.m", "wb",
		"class equates file");
	fprintf(classEquatesFile, ";\n; class_equates.m\n");
	fprintf(classEquatesFile, ";\n; Generated by Muddle\n");
	theTime = time(0);
	fprintf(classEquatesFile, "; %s;\n", ctime(&theTime));
	nextFreeClass = 0;

	widthFile = openFile("width.incl.pl1", "wb", "pl1 width table file");
	fprintf(widthFile, "/*\n * width.incl.pl1\n");
	fprintf(widthFile, " * Generated by Muddle\n");
	fprintf(widthFile, " * %s */\n", ctime(&theTime));

	pl1File = openFile("capacity.incl.pl1", "wb", "pl1 init table file");
	fprintf(pl1File, "/*\n * capacity.incl.pl1\n");
	fprintf(pl1File, " * Generated by Muddle\n");
	fprintf(pl1File, " * %s */\n", ctime(&theTime));

	images.outputFile = openFile("image.dat", "wb", "image output file");
	maxItem[(int)IMAGE_ITEM] = images.nextFreeEntry = 0;
	images.name = "Images";

	sounds.outputFile = openFile("sound.dat", "wb", "sound output file");
	maxItem[(int)SOUND_ITEM] = sounds.nextFreeEntry = 0;
	sounds.name = "Sounds";

	actions.outputFile=openFile("action.dat", "wb", "action output file");
	maxItem[(int)ACTION_ITEM] = actions.nextFreeEntry = 0;
	actions.name = "Actions";

	heads.outputFile = openFile("head.dat", "wb", "head output file");
	maxItem[(int)HEAD_ITEM] = heads.nextFreeEntry = 0;
	heads.name = "Heads";

	for (i=0; i<TABLE_SIZE; ++i) {
		widthTable[i] = 0;
		flipOffsetTable[i] = 0;
		imageXLeftTable[i] = 0;
		imageXRightTable[i] = 0;
		imageYTable[i] = 0;
		classTable[i] = 0;
		theClasses[i] = NULL;
		images.table[i] = 0;
		images.fileNames[i] = NULL;
		sounds.table[i] = 0;
		sounds.fileNames[i] = NULL;
		actions.table[i] = 0;
		actions.fileNames[i] = NULL;
		heads.table[i] = 0;
		heads.fileNames[i] = NULL;
	}
	for (i=0; i<HASH_TABLE_SIZE; ++i) {
		symbolTable[i] = NULL;
	}
}

  FILE *
openFile(fileName, mode, description)
  char	*fileName;
  char	*mode;
  char	*description;
{
	FILE	*result;
	void	 fatalError();

	if ((result = fopen(fileName, mode)) == NULL)
		fatalError("unable to open %s '%s'\n", description, fileName);
	return(result);
}

  void
error(message, arg1, arg2, arg3)
  char	*message;
  int	 arg1;
  int	 arg2;
  int	 arg3;
{
	fprintf(stderr, message, arg1, arg2, arg3);
}

  void
fatalError(message, arg1, arg2, arg3)
  char	*message;
  int	 arg1;
  int	 arg2;
  int	 arg3;
{
	fprintf(stderr, "fatal error: ");
	error(message, arg1, arg2, arg3);
	exit(1);
}
